'''
Домашнє завдання 7



1. Прочитайте цей набір даних пауерліфтингу в pandas DataFrame.

https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-

10-08/ipf_lifts.csv



2. Знайдіть рекорди кожної статі та кожного підрозділу в кожній із 3 вправ (жим лежачи, присідання та станова тяга).



3. Порахуйте кількість перемог кожного учасника, беручи за перемогу 1-е місце в конкретному дивізіоні



4. Використайте DataFrame з вправи 3, щоб показати для кожної комбінації підрозділу та статі, 
учасника з найбільшою кількістю перемог серед учасників, які будь-коли брали участь у цьому дивізіоні.




Рекомендації по виконанню:


1. Прочитайте цей набір даних пауерліфтингу в pandas DataFrame.

	https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-10-08/ipf_lifts.csv

	Спочатку перевіряється наявність файлу 'ipf_lifts.csv' в поточному каталозі. Якщо файл вже існує, програма просто продовжує виконання.
      У протилежному випадку відбувається завантаження файлу з вказаної URL-адреси.

	Перевіряється наявність файлу ' ipf_lifts.csv' за допомогою функції os.path.exists().

	Якщо файл не існує, виконується HTTP-запит за допомогою бібліотеки requests для отримання вмісту документа за URL-адресою.

	Якщо статус відповіді є успішним, тобто

	requests.get(' URL-адреса').status_code == 200

(код 200), отриманий вміст записується у файл з розширенням csv.

	Завантажений файл зчитується у DataFrame за допомогою функції pandas.read_table().

	2 завдання

Дані спочатку групуються за статтю та підрозділом. Потім для кожної комбінації статі 
та підрозділу обчислюються максимальні значення трьох підйомів (bench press, squat, deadlift). 
Результати зберігаються у новому DataFrame. Кожен рядок цього DataFrame відповідає комбінації статі та підрозділу,
 а стовпці відображають максимальні значення для кожного типу підйому, тобто:

      sex  division                                                  

	F  Heavy               192.5         305.0            248.5

	    Juniors              190.5         282.5            252.5

	    Light                 150.0         220.0            202.5

	    Masters 1          197.5         245.0            248.0

	    Masters 2          172.5         255.0            227.5

	    Masters 3          140.0         210.0            190.0

	    Masters 4          115.0         135.0            142.5

	    Middle              170.0         247.5            235.0

	     Open                    235.0          322.5            270.5

	     Sub-Juniors         170.0          265.0            238.0

	     Super                   190.0          267.5            245.0

	     SuperHeavy         205.0         310.5            247.5

	M  Heavy                  330.0         432.0            382.5

	      Juniors                375.0         450.0            377.5

	      Light                   217.5         325.5            315.0

	      Masters 1            345.0         405.0            395.0

	      Masters 2            310.5         365.0            335.0

	      Masters 3            260.0         300.0            305.0

	      Masters 4            220.0         235.0            260.5

	      Middle                268.5         370.0            345.0

	      Open                   415.0         490.0            407.5

	      Sub-Juniors        310.0         370.0            335.0

	      Super                  360.0         465.0            387.5

	      SuperHeavy       405.0         475.0            420.0

	 

	3 завдання

Існує щонайменше 5 підходів до рішення цього завдання. 

	Спочатку вибиремо всі рядки з DataFrame, де значення в стовпці "place" рівне "1". Тобто, це вибір всіх учасників, які посіли перше місце у змаганнях. 
    Результат зберігається у новому DataFrame df_winners. Таким чином, DataFrame df_winners міститиме дані лише про переможців у кожному змаганні.

	    У всіх п'яти підходах до підрахунку кількості перемог кожного учасника використовуються методи групування та агрегації даних за ім'ям учасника,
          яке зберігається у стовпці "name", та дивізіоном, який зберігається у стовпці "division". Далі, для кожного учасника, що має перше місце, 
          обчислюється кількість його перемог.

1)   В першому підході використовується метод groupby для групування даних за ім'ям учасника та дивізіоном, після чого використовується 
метод agg для обчислення кількості перемог за допомогою функції count. Результат зберігається у новому DataFrame.

2)   У другому підході також використовується метод groupby для групування даних, але для обчислення кількості перемог використовується функція size, 
яка повертає кількість рядків у кожній групі. Результати зберігаються у новому DataFrame.

3)   Третій підхід використовує метод size() безпосередньо на групі df_winners['name', 'division'] для підрахунку кількості перемог кожного учасника. 
Результати зберігаються у новому DataFrame.

4)   Четвертий підхід є аналогічним до третього, але використовується метод count(), який підраховує кількість непорожніх елементів у кожній групі. 
Результати зберігаються у новому DataFrame.

5)   У п'ятому підході використовується метод value_counts(), 
який обчислює кількість кожного унікального значення у списку стовпців [['name', 'division']]. Результат зберігається у новому DataFrame.

Отриманий DataFrame містить 3881 рядка.

4       завдання

1)   Отриманий DataFrame об'єднаємо з основним DataFrame за допомогою методу merge. 

	Параметри виконання методу merge:

-        how='left' - це тип об'єднання, вказує, що залишаємо всі рядки з основного DataFrame і додаємо відповідні дані з DataFrame з попереднього завдання. 
Якщо значення індексу з основного DataFrame є унікальними, то кількість рядків в результуючому DataFrame буде збігатися з кількістю рядків основного DataFrame.

-        on=['name', 'division'] - це стовпці, за якими проводиться об'єднання. У нашому випадку,
 об'єднання відбувається за стовпцями 'name' і 'division', тобто ми використовуємо ім'я учасника та дивізіон для об'єднання двох таблиць.

Після виконання цієї операції, ми отримаємо новий DataFrame, що містить дані про кожного учасника з основного DataFrame, 
а також дані про кількість перемог, які вони отримали в своїх дивізіонах. 

2)   Розрахунок максимальної кількості перемог для кожної комбінації підрозділу та статі:

Використовуючи groupby, ми групуємо дані за колонками "division" та "sex". Далі ми використовуємо метод transform('max'), 
щоб для кожної групи знайти максимальне значення кількості перемог. Це робиться за допомогою стовпця, який визначає кількість перемог кожного учасника. 

4) Відбір учасників з максимальною кількістю перемог:

Ми відбираємо рядки, де значення стовпця кількості перемог дорівнює максимальним значенням, розрахованим у попередньому кроці.

4)   Видалення дублікатів:

Щоб уникнути дублікатів учасників, які мають однакову кількість перемог, ми використовуємо метод drop_duplicates(). 
Ми вказуємо стовпці, за якими слід визначити унікальність рядків, вказавши subset=['division', 'sex', 'name'].

Друкуємо новий DataFrame, щоб побачити унікальних переможців для кожного комбінації підрозділу та статі:

             division        sex     name count_wins

2199     Light            M       Sergey Fedosienko         2.0

2209     Middle         M       Jarosław Olech               3.0

2219     Heavy          M        Vadym Dovhanyuk        1.0

2222     Heavy          M        Sergii Bilyi                     1.0

2229     Super           M        Andrey Konovalov #1    1.0

2239     Light            F         Natalia Salnikova           2.0

2249     Middle         F          Larysa Soloviova           2.0

2257     Heavy          F          Ana Rosa Castellain       2.0

2267     Super           F          Olena Kozlova               1.0

2314     Juniors         M        Kirill Krut                       6.0

2388     Sub-Juniors  F         Daniela Kolesnik            8.0

2573     Juniors         M        Kevin Jäger #1                6.0

2674     Masters 4     M        Bill Helmich                   8.0

2703     Open            F         Ielja Strik                        20.0

2727     Juniors         F         Marta Sroczyk                 7.0

2765     Masters 3     F         Chiyomi Sawa                 7.0

3454     Sub-Juniors  M        Norbert Mikula               4.0

4148     Masters 3     M        Hiraku Fushimi                8.0

4250     SuperHeavy M        Oleksiy Rokochyy Jr       1.0

4290     SuperHeavy F         Bonica Brown                  1.0

4572    Masters 4     M         Kazimierz Michael Forys     8.0

5179    Masters 2     F          Hana Takáčová                      10.0

5202    Masters 4     F          Bebe Burns                            8.0

5731    Open            M         Sergey Fedosienko                20.0

5905    Juniors         M         Dalton LaCoe                        6.0

6416    Masters 1     F          Priscilla Ribic                         9.0

6803    Masters 2     M         Hideaki Inaba                         10.0

7967    Masters 1     M         Eric Kupperstein                     9.0

8363    Masters 3     F           Hana Takáčová                       7.0

25482  Heavy          M          Nikolay Suslov                      1.0

36415  Heavy          M          Sergiy Pevnev                        1.0

36425  Super           M          Michael Tuchscherer              1.0

36464  Super           F           Iryna Karpova-Yavorska        1.0

37605  Light           M           Alexey Sivokon                      2.0

37619  Heavy         M          Sturla Davidsen                       1.0

37623  Heavy         M          Daisuke Midote                       1.0
'''